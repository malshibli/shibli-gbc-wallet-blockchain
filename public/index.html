<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>SHIBLI GBC Wallet</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>

  <style>
    body { font-family: Segoe UI, sans-serif; background:#f5faff; color:#2b4f81; margin:0; }
    header { background:#2b4f81; color:#fff; padding:18px; text-align:center; font-size:22px; }
    .section { max-width:900px; margin:18px auto; padding:18px; background:#fff; border-radius:14px; box-shadow:0 4px 12px rgba(0,0,0,.06); }
    h2 { margin:0 0 10px; }
    input, button, textarea { width:100%; padding:12px; margin:8px 0; border-radius:8px; border:1px solid #ccd6e5; font-size:15px; box-sizing:border-box; }
    button { background:#2b4f81; color:#fff; border:none; cursor:pointer; }
    button:hover { background:#1d3d66; }
    .muted { opacity:.85; font-size:14px; }
    .row { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    @media (max-width:800px){ .row { grid-template-columns:1fr; } }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; background:#eef6ff; border:1px dashed #b8cbe6; }
    .danger { background:#fff2f2; border:1px solid #ffd0d0; color:#8b1f1f; padding:12px; border-radius:10px; }
    .ok { background:#f2fff7; border:1px solid #c7f2da; color:#136b3a; padding:12px; border-radius:10px; }
    .admin-panel { display:none; }
    .mini { font-size:13px; opacity:.85; }
    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:12px; }
    @media (max-width:800px){ .grid3 { grid-template-columns:1fr; } }
  </style>
</head>

<body>
<header><i class="fas fa-globe"></i> SHIBLI GBC Wallet</header>

<div class="section">
  <h2><i class="fas fa-leaf"></i> Welcome to SHIBLI GBC</h2>
  <div class="muted">Initiated by Professor Murad Al Shibli.</div>
  <p class="muted">
    Dignity-based universal income • Equal global entitlement • Empowerment for all humanity
  </p>
</div>

<div class="section">
  <h2><i class="fas fa-plug"></i> Wallet Connection</h2>
  <div id="web3Hint" class="danger" style="display:none;">
    <b>MetaMask / Web3 not detected</b><br/>
    On Android, open this site inside <b>MetaMask → Browser</b>.
    <div style="margin-top:10px;">
      <button onclick="copyLink()"><i class="fas fa-copy"></i> Copy this page link</button>
    </div>
  </div>

  <div class="row">
    <div>
      <div><b>Connected Wallet:</b> <span id="walletAddress" class="pill">Not Connected</span></div>
      <button onclick="connectWallet()"><i class="fas fa-link"></i> Connect MetaMask</button>
      <div class="muted">Network: <span id="networkName">-</span></div>
      <div class="mini">Entitlement Contract Admin: <span id="0xdD42416E63F0D1eB2B00d01ec0fF8191CF8d42D1
" class="pill">-</span></div>
    </div>
    <div>
      <div><b>GBC Balance:</b> <span id="gbcBalance" class="pill">-</span></div>
      <button onclick="refreshBalance()"><i class="fas fa-rotate"></i> Refresh Balance</button>
      <div class="mini">Contract: <span id="contractHint" class="pill">-</span></div>
    </div>
  </div>

  <div id="globalStatus" style="margin-top:10px;"></div>
</div>

<div class="section">
  <h2><i class="fas fa-user-check"></i> Request GBC (Off-chain request → Admin approval)</h2>
  <div class="muted">This creates a request record. Approval + cap enforcement happens on-chain.</div>

  <form id="requestForm">
    <input name="fullName" placeholder="Full Name" required />
    <input name="nationalId" placeholder="National ID / Passport No" required />
    <input id="requestWallet" name="wallet" placeholder="MetaMask Wallet Address" required />
    <input name="amount" type="number" step="0.000000000000000001" placeholder="Requested Amount (e.g. 0.0125)" required />

    <label class="muted">Notes (optional)</label>
    <textarea name="notes" rows="3" placeholder="Optional notes…"></textarea>

    <button type="submit"><i class="fas fa-paper-plane"></i> Submit Request</button>
  </form>

  <div id="requestResult" style="margin-top:10px;"></div>
</div>

<div class="section">
  <h2><i class="fas fa-clipboard-check"></i> My Request Status</h2>

  <div class="row">
    <input id="statusWallet" placeholder="Paste your wallet (or connect)"/>
    <button onclick="checkStatus()"><i class="fas fa-search"></i> Check Status</button>
  </div>

  <div id="statusBox" style="margin-top:10px;"></div>

  <!-- ✅ STEP 2: richer on-chain status (approved amount, cap, claimed) -->
  <div style="margin-top:14px;">
    <div class="grid3">
      <div>
        <div class="muted"><b>On-chain Approved?</b></div>
        <div id="onchainApproved" class="pill">-</div>
      </div>
      <div>
        <div class="muted"><b>Approved Amount</b></div>
        <div id="onchainApprovedAmount" class="pill">-</div>
      </div>
      <div>
        <div class="muted"><b>Entitlement Cap</b></div>
        <div id="onchainCap" class="pill">-</div>
      </div>
    </div>

    <div class="grid3" style="margin-top:10px;">
      <div>
        <div class="muted"><b>Already Claimed?</b></div>
        <div id="onchainClaimed" class="pill">-</div>
      </div>
      <div>
        <div class="muted"><b>Wallet (checked)</b></div>
        <div id="onchainWalletChecked" class="pill">-</div>
      </div>
      <div>
        <div class="muted"><b>Network</b></div>
        <div id="onchainNetwork" class="pill">-</div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <button onclick="claimIfApproved()"><i class="fas fa-gift"></i> Claim Approved GBC</button>
      <div class="muted">Claim works only if you were approved on-chain and not claimed before.</div>
    </div>
  </div>
</div>

<div class="section admin-panel" id="adminPanel">
  <h2><i class="fas fa-shield-alt"></i> Admin Panel (Treasury/Approver Only)</h2>
  <div class="ok">
    This panel is shown only if your connected wallet matches the <b>admin</b> address stored on-chain in the entitlement contract.
  </div>

  <input id="adminUser" placeholder="User wallet to approve" />
  <input id="adminAmount" placeholder="Approved amount (must be <= cap)" />
  <button onclick="approveOnChain()"><i class="fas fa-check-circle"></i> Approve On-Chain</button>

  <hr style="border:none;border-top:1px solid #eef2f8;margin:14px 0;">
  <div class="muted">After approving on-chain, also update request status in database (optional but recommended).</div>

  <input id="adminReqId" placeholder="Request ID from DB (optional)" />
  <button onclick="markApprovedInDB()"><i class="fas fa-database"></i> Mark Approved in DB</button>

  <div id="adminResult" style="margin-top:10px;"></div>
</div>

<script>
  // =========================================================
  // ✅ STEP 2 UPDATE (based on YOUR code):
  // 1) Admin lock is NOT hardcoded anymore -> read admin() from the contract
  // 2) Admin actions are blocked unless connected wallet == on-chain admin
  // 3) On-chain entitlement status shows: approved, approvedAmount, cap, claimed
  // =========================================================

  // ======= CONFIG (EDIT THESE) =======
  const GBC_TOKEN_ADDRESS = "0x03e53f9a402e88a56ef31f95908424951042cfa3"; // your token (ERC-20)
  const ENTITLEMENT_CONTRACT = "0x03e53f9a402e88a56ef31f95908424951042cfa3";      // deploy result (GBCEntitlement)
  const EXPECTED_CHAIN_ID = 11155111; // Sepolia (change if you use another network)

  // ABI for ERC20 balance
  const ERC20_ABI = [
    {"constant":true,"inputs":[{"name":"a","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
    {"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"type":"function"},
    {"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"type":"function"},
  ];

  // ABI for entitlement contract (extended to support Step 2 UI)
  // NOTE: Your previous ABI used approveUser/isApproved/approvedAmount.
  // This ABI keeps those AND adds admin(), entitlementCap(), hasClaimed() if present.
  const ENTITLEMENT_ABI = [
    // admin + cap (Step 2 lock + display)
    {"inputs":[],"name":"admin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"entitlementCap","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},

    // claim + approvals
    {"inputs":[],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"isApproved","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"approvedAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},

    // admin function (your original)
    {"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approveUser","outputs":[],"stateMutability":"nonpayable","type":"function"},

    // optional, if your contract has this (Step 2 claimed status)
    // If the function doesn't exist on your deployed contract, we handle it gracefully.
    {"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"hasClaimed","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
  ];

  let provider, signer, walletAddress;
  let cachedAdmin = null;
  let cachedCap = null;

  function el(id){ return document.getElementById(id); }

  function showGlobal(msg, type){
    const box = el("globalStatus");
    if(!box) return;
    if(!msg){ box.innerHTML = ""; return; }
    box.innerHTML = `<div class="${type === 'ok' ? 'ok' : 'danger'}">${msg}</div>`;
  }

  function shortAddr(a){
    if(!a || typeof a !== "string") return "-";
    return a.slice(0,6) + "…" + a.slice(-4);
  }

  function copyLink(){
    navigator.clipboard.writeText(location.href);
    alert("Link copied. Open MetaMask → Browser → paste and open.");
  }

  async function getNetworkSafe(){
    try{
      if(!provider) return null;
      return await provider.getNetwork();
    }catch(e){
      return null;
    }
  }

  async function getEntitlementRead(){
    if(!provider) throw new Error("Provider not ready");
    return new ethers.Contract(ENTITLEMENT_CONTRACT, ENTITLEMENT_ABI, provider);
  }

  async function getEntitlementWrite(){
    if(!signer) throw new Error("Connect wallet first");
    return new ethers.Contract(ENTITLEMENT_CONTRACT, ENTITLEMENT_ABI, signer);
  }

  async function loadContractAdminAndCap(){
    try{
      const ent = await getEntitlementRead();
      // admin()
      cachedAdmin = await ent.admin();
      el("adminAddress").innerText = shortAddr(cachedAdmin);

      // entitlementCap()
      try{
        cachedCap = await ent.entitlementCap();
      }catch(_e){
        cachedCap = null;
      }

      el("contractHint").innerText = shortAddr(ENTITLEMENT_CONTRACT);
    }catch(e){
      cachedAdmin = null;
      cachedCap = null;
      el("adminAddress").innerText = "-";
      el("contractHint").innerText = shortAddr(ENTITLEMENT_CONTRACT);
    }
  }

  function applyAdminVisibility(){
    const panel = el("adminPanel");
    if(!panel) return;

    if(!walletAddress || !cachedAdmin){
      panel.style.display = "none";
      return;
    }
    const isAdmin = walletAddress.toLowerCase() === cachedAdmin.toLowerCase();
    panel.style.display = isAdmin ? "block" : "none";
  }

  async function connectWallet(){
    if(!window.ethereum){
      el("web3Hint").style.display = "block";
      return;
    }
    provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    signer = provider.getSigner();
    walletAddress = await signer.getAddress();

    el("walletAddress").innerText = shortAddr(walletAddress);
    el("requestWallet").value = walletAddress;
    el("statusWallet").value = walletAddress;

    const net = await provider.getNetwork();
    el("networkName").innerText = `${net.name} (chainId ${net.chainId})`;

    // Step 2: read admin from contract and lock panel dynamically
    await loadContractAdminAndCap();
    applyAdminVisibility();

    // show network warning
    if(net.chainId !== EXPECTED_CHAIN_ID){
      showGlobal(`<b>Wrong network</b>: switch to Sepolia (chainId ${EXPECTED_CHAIN_ID}) then refresh.`, "danger");
    } else {
      showGlobal(`<b>Connected</b>. Wallet ready.`, "ok");
    }

    await refreshBalance();
    await refreshOnChainStatus(walletAddress);

    // Auto refresh on account/network change
    if(window.ethereum.on){
      window.ethereum.on("accountsChanged", async () => {
        signer = provider.getSigner();
        walletAddress = await signer.getAddress();
        el("walletAddress").innerText = shortAddr(walletAddress);
        el("requestWallet").value = walletAddress;
        el("statusWallet").value = walletAddress;
        await loadContractAdminAndCap();
        applyAdminVisibility();
        await refreshBalance();
        await refreshOnChainStatus(walletAddress);
      });
      window.ethereum.on("chainChanged", () => location.reload());
    }
  }

  async function refreshBalance(){
    if(!provider || !walletAddress){
      el("gbcBalance").innerText = "-";
      return;
    }
    try{
      const token = new ethers.Contract(GBC_TOKEN_ADDRESS, ERC20_ABI, provider);
      const dec = await token.decimals();
      const bal = await token.balanceOf(walletAddress);
      el("gbcBalance").innerText = ethers.utils.formatUnits(bal, dec);
    }catch(e){
      el("gbcBalance").innerText = "Error";
    }
  }

  // ----- Off-chain request storage (Vercel API) -----
  el("requestForm").addEventListener("submit", async (e)=>{
    e.preventDefault();
    const form = new FormData(e.target);
    const payload = Object.fromEntries(form.entries());

    const box = el("requestResult");
    box.innerHTML = "Submitting…";

    try{
      const res = await fetch("/api/request", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });
      const data = await res.json();
      if(!res.ok) throw new Error(data.error || "Request failed");
      box.innerHTML = `<div class="ok"><b>Submitted.</b> Request ID: <code>${data.id}</code> • Status: ${data.status}</div>`;
    }catch(err){
      box.innerHTML = `<div class="danger"><b>Error:</b> ${err.message}</div>`;
    }
  });

  async function checkStatus(){
    const w = (el("statusWallet").value || "").trim();
    const box = el("statusBox");
    if(!w){ box.innerHTML = `<div class="danger">Enter wallet.</div>`; return; }

    box.innerHTML = "Checking…";

    // also refresh on-chain status for the same wallet
    await refreshOnChainStatus(w);

    try{
      const res = await fetch(`/api/status?wallet=${encodeURIComponent(w)}`);
      const data = await res.json();
      if(!res.ok) throw new Error(data.error || "Status error");

      if(!data.found){
        box.innerHTML = `<div class="danger">No request found for this wallet.</div>`;
        return;
      }

      box.innerHTML = `
        <div class="${data.status === 'APPROVED' ? 'ok' : 'danger'}">
          <b>Status:</b> ${data.status}<br/>
          <b>Requested:</b> ${data.requestedAmount || '-'}<br/>
          <b>Approved:</b> ${data.approvedAmount || '-'}<br/>
          <b>Request ID:</b> <code>${data.id}</code><br/>
          ${data.txHash ? `<b>On-chain Tx:</b> <code>${data.txHash}</code><br/>` : ``}
        </div>
      `;
    }catch(err){
      box.innerHTML = `<div class="danger"><b>Error:</b> ${err.message}</div>`;
    }
  }

  // ✅ Step 2: on-chain status panel
  async function refreshOnChainStatus(wallet){
    el("onchainWalletChecked").innerText = wallet ? shortAddr(wallet) : "-";

    const net = await getNetworkSafe();
    if(net){
      el("onchainNetwork").innerText = `${net.name} (${net.chainId})`;
    } else {
      el("onchainNetwork").innerText = "-";
    }

    // default placeholders
    el("onchainApproved").innerText = "-";
    el("onchainApprovedAmount").innerText = "-";
    el("onchainCap").innerText = cachedCap ? (ethers.utils.formatUnits(cachedCap, 18) + " GBC") : "-";
    el("onchainClaimed").innerText = "-";

    try{
      if(!provider) return;

      const ent = await getEntitlementRead();

      // approved?
      const approved = await ent.isApproved(wallet);
      el("onchainApproved").innerText = approved ? "APPROVED ✅" : "NOT APPROVED ⛔";

      // approvedAmount
      const amt = await ent.approvedAmount(wallet);
      el("onchainApprovedAmount").innerText = ethers.utils.formatUnits(amt, 18) + " GBC";

      // cap (if not yet loaded)
      if(!cachedCap){
        try{
          cachedCap = await ent.entitlementCap();
          el("onchainCap").innerText = ethers.utils.formatUnits(cachedCap, 18) + " GBC";
        }catch(_e){
          // ignore
        }
      }

      // claimed? (optional)
      try{
        const claimed = await ent.hasClaimed(wallet);
        el("onchainClaimed").innerText = claimed ? "YES ✅" : "NO";
      }catch(_e){
        el("onchainClaimed").innerText = "N/A";
      }
    }catch(e){
      // if contract doesn't match ABI, show graceful message
      el("onchainApproved").innerText = "Error";
      el("onchainApprovedAmount").innerText = "Error";
      el("onchainClaimed").innerText = "Error";
    }
  }

  // ----- On-chain claim -----
  async function claimIfApproved(){
    if(!signer) { alert("Connect wallet first."); return; }

    const net = await provider.getNetwork();
    if(net.chainId !== EXPECTED_CHAIN_ID){
      alert(`Wrong network. Please switch to Sepolia (chainId ${EXPECTED_CHAIN_ID}).`);
      return;
    }

    try{
      const ent = await getEntitlementWrite();
      const approved = await ent.isApproved(walletAddress);
      if(!approved){ alert("Not approved on-chain yet."); return; }

      // optional claimed check
      try{
        const claimed = await ent.hasClaimed(walletAddress);
        if(claimed){ alert("Already claimed."); return; }
      }catch(_e){}

      const tx = await ent.claim();
      alert("Claim submitted. Waiting confirmation…");
      await tx.wait();
      alert("Claim success ✅");

      await refreshBalance();
      await refreshOnChainStatus(walletAddress);
      // also refresh DB status view if user pressed it
      // (safe to call; it will show error if no request exists)
      try { await checkStatus(); } catch(_e){}
    }catch(e){
      alert(e?.data?.message || e.message || "Claim failed");
    }
  }

  // ----- Admin: approve on-chain -----
  async function approveOnChain(){
    if(!signer) { alert("Connect wallet first."); return; }

    const net = await provider.getNetwork();
    if(net.chainId !== EXPECTED_CHAIN_ID){
      alert(`Wrong network. Please switch to Sepolia (chainId ${EXPECTED_CHAIN_ID}).`);
      return;
    }

    // ✅ Step 2 lock: admin is checked on-chain (not hardcoded)
    await loadContractAdminAndCap();
    if(!cachedAdmin || walletAddress.toLowerCase() !== cachedAdmin.toLowerCase()){
      alert("Not admin wallet (on-chain).");
      applyAdminVisibility();
      return;
    }

    const user = el("adminUser").value.trim();
    const amt = el("adminAmount").value.trim();
    const out = el("adminResult");
    if(!user || !amt){ out.innerHTML = `<div class="danger">Enter user + amount.</div>`; return; }

    out.innerHTML = "Sending approval tx…";
    try{
      const ent = await getEntitlementWrite();

      // cap guard (if cap exists)
      try{
        const cap = cachedCap ? cachedCap : await ent.entitlementCap();
        const amtWei = ethers.utils.parseUnits(String(amt), 18);
        if(amtWei.gt(cap)){
          out.innerHTML = `<div class="danger"><b>Error:</b> Amount exceeds entitlement cap.</div>`;
          return;
        }
      }catch(_e){}

      const tx = await ent.approveUser(user, ethers.utils.parseUnits(String(amt), 18));
      out.innerHTML = `<div class="ok">Tx sent: <code>${tx.hash}</code> (waiting…)</div>`;
      await tx.wait();
      out.innerHTML = `<div class="ok"><b>Approved on-chain ✅</b><br/>Tx: <code>${tx.hash}</code></div>`;

      // refresh on-chain status panel for that user
      await refreshOnChainStatus(user);
    }catch(err){
      out.innerHTML = `<div class="danger"><b>Error:</b> ${err?.data?.message || err.message || "Approval failed"}</div>`;
    }
  }

  // ----- Admin: mark approved in DB -----
  async function markApprovedInDB(){
    if(!signer) { alert("Connect wallet first."); return; }

    // ✅ Step 2 lock: admin is checked on-chain (not hardcoded)
    await loadContractAdminAndCap();
    if(!cachedAdmin || walletAddress.toLowerCase() !== cachedAdmin.toLowerCase()){
      alert("Not admin wallet (on-chain).");
      applyAdminVisibility();
      return;
    }

    const requestId = el("adminReqId").value.trim();
    const user = el("adminUser").value.trim();
    const amt = el("adminAmount").value.trim();

    const out = el("adminResult");
    out.innerHTML = "Updating database…";

    try{
      const res = await fetch("/api/admin/approve", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ requestId, wallet:user, approvedAmount:amt })
      });
      const data = await res.json();
      if(!res.ok) throw new Error(data.error || "DB update failed");
      out.innerHTML = `<div class="ok"><b>DB updated ✅</b> Request: <code>${data.id}</code> Status: ${data.status}</div>`;
    }catch(err){
      out.innerHTML = `<div class="danger"><b>Error:</b> ${err.message}</div>`;
    }
  }

  // Auto hint if no provider
  if(!window.ethereum){
    el("web3Hint").style.display = "block";
  } else {
    // Pre-fill hints even before connect
    el("contractHint").innerText = shortAddr(ENTITLEMENT_CONTRACT);
  }
</script>
</body>
</html>
